#pragma once
#include <queue>

#include "stdafx.h"
#include "PacketList.h"
#include "TemplateSingleton.h"
#include "ClientSession.h"


struct ClientPacket
{
	ClientPacket() : m_Session(nullptr) { memset(m_Buffer, 0, MAX_BUFSIZE); }
	ClientPacket(ClientSession* client, char* buffer, DWORD bufferSize) : m_Session(client)
	{
		memset(m_Buffer, 0, MAX_BUFSIZE);
		memcpy(m_Buffer, buffer, bufferSize);
	}

	ClientSession* m_Session;
	char m_Buffer[MAX_BUFSIZE];
};

/*
클래스명 : PacketManager
기능 : workerThread 에서 받은 패킷을 해당 클래스내 Queue 에 저장하고,
	   이 클래스내에 저장된 패킷을 별도의 스레드에서 처리하며,
	   패킷 정보에 따른 처리로직을 포함함.

흐름 : workerThread -> PacketQueue -> ProcessPacketThread
*/
// PacketManager Is-A Singleton : PacketManager 은 Singleton 형태이다.
// 2021-03-10 : singleton -> extern 형태로 변경
class PacketManager
{
public:
	PacketManager();
	~PacketManager();

	void Init();
	void Clean();

	// 해당 클래스는 싱글톤, 또는 전역으로 사용될 목적이기에
	// thread-safe 하게 설계되어야한다.
	// 따라서 CRITICAL_SECTION 등의 처리가 필수적이다.
	bool Enqueue(ClientPacket pack);		// 패킷을 Queue 안에 저장
	bool Dequeue(ClientPacket& pack);		// 패킷을 Queue 에서 삭제

	// 패킷처리
	void ProcessAllQueue();		// 모든 패킷이 Queue 에서 전부 빠질 때까지 패킷처리를 계속함

	// Send 패킷생성
	bool MakeSendPacket(ClientSession* client, char* buffer, DWORD dataBufferSize, PROTOCOL protocol);

	// 패킷분석
	PROTOCOL ParsingPacket(ClientPacket pack);		// HEAD 를 분리하여 패킷 정보를 분석 -> 어떤 프로토콜을 실행해야하는지 판단	
	bool CheckAvailablePacket(char* buffer, DWORD dataBufferSize);	// HEAD 를 분리하여 패킷사이즈가 정상적인지 확인
	DWORD GetTotalPacketSize(char* buffer, DWORD dataBufferSize);

	// 프로토콜에 따른 패킷 처리
	void ProcessPacket(PROTOCOL protocol, ClientPacket pack);

	// 편의를 위한 CRITICAL_SECTION 함수
	void EnterCS() { EnterCriticalSection(&m_CS); }
	void LeaveCS() { LeaveCriticalSection(&m_CS); }

	void SetIsStop(bool isStop) { m_IsStop = isStop; }
private:
	// PacketManager Have-A Queue
	// 패킷처리 클래스에서는 패킷을 저장할 별도의 큐를 가진다.
	// 클라이언트에서 보낸 패킷을 쌓아두고, 별도의 ProcessPacketThread 를 통해 패킷정보를 처리한다.
	queue<ClientPacket> m_BufferQueue;

	// for thread-safe
	CRITICAL_SECTION m_CS;

	// while loop stop flag
	bool m_IsStop;
};

extern PacketManager* g_pPacketManager;